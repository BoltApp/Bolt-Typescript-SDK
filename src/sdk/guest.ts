/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks/hooks.js";
import { SDKOptions, serverURLFromOptions } from "../lib/config.js";
import { encodeJSON as encodeJSON$, encodeSimple as encodeSimple$ } from "../lib/encodings.js";
import { HTTPClient } from "../lib/http.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import { SecurityInput } from "../lib/security.js";
import * as components from "../models/components/index.js";
import * as errors from "../models/errors/index.js";
import * as operations from "../models/operations/index.js";

export class Guest extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    /**
     * Initialize a Bolt payment for guest shoppers
     *
     * @remarks
     * Initialize a Bolt guest shopper's intent to pay for a cart, using the specified payment method. Payments must be finalized before indicating the payment result to the shopper. Some payment methods will finalize automatically after initialization. For these payments, they will transition directly to "finalized" and the response from Initialize Payment will contain a finalized payment.
     */
    async initialize(
        security: operations.GuestPaymentsInitializeSecurity,
        xPublishableKey: string,
        xMerchantClientId: string,
        guestPaymentInitializeRequest: components.GuestPaymentInitializeRequest,
        options?: RequestOptions
    ): Promise<operations.GuestPaymentsInitializeResponse> {
        const input$: operations.GuestPaymentsInitializeRequest = {
            xPublishableKey: xPublishableKey,
            xMerchantClientId: xMerchantClientId,
            guestPaymentInitializeRequest: guestPaymentInitializeRequest,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GuestPaymentsInitializeRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$["guest-payment-initialize-request"], {
            explode: true,
        });

        const path$ = this.templateURLComponent("/guest/payments")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            "X-Merchant-Client-Id": encodeSimple$(
                "X-Merchant-Client-Id",
                payload$["X-Merchant-Client-Id"],
                { explode: false, charEncoding: "none" }
            ),
            "X-Publishable-Key": encodeSimple$("X-Publishable-Key", payload$["X-Publishable-Key"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$: SecurityInput[][] = [
            [
                {
                    fieldName: "X-API-Key",
                    type: "apiKey:header",
                    value: security?.apiKey,
                },
            ],
        ];
        const securitySettings$ = this.resolveSecurity(...security$);
        const context = {
            operationID: "guestPaymentsInitialize",
            oAuth2Scopes: [],
            securitySource: security$,
        };

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.GuestPaymentsInitializeResponse>()
            .json(200, operations.GuestPaymentsInitializeResponse$inboundSchema, {
                key: "payment-response",
            })
            .json("4XX", errors.GuestPaymentsInitializeResponseBody$inboundSchema, { err: true })
            .fail("5XX")
            .void("default", operations.GuestPaymentsInitializeResponse$inboundSchema)
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Update a pending guest payment
     *
     * @remarks
     * Update a guest payment that is still in the pending state, with new information about the payment.
     */
    async update(
        security: operations.GuestPaymentsUpdateSecurity,
        id: string,
        xPublishableKey: string,
        xMerchantClientId: string,
        paymentUpdateRequest: components.PaymentUpdateRequest,
        options?: RequestOptions
    ): Promise<operations.GuestPaymentsUpdateResponse> {
        const input$: operations.GuestPaymentsUpdateRequest = {
            id: id,
            xPublishableKey: xPublishableKey,
            xMerchantClientId: xMerchantClientId,
            paymentUpdateRequest: paymentUpdateRequest,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GuestPaymentsUpdateRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$["payment-update-request"], { explode: true });

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };
        const path$ = this.templateURLComponent("/guest/payments/{id}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            "X-Merchant-Client-Id": encodeSimple$(
                "X-Merchant-Client-Id",
                payload$["X-Merchant-Client-Id"],
                { explode: false, charEncoding: "none" }
            ),
            "X-Publishable-Key": encodeSimple$("X-Publishable-Key", payload$["X-Publishable-Key"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$: SecurityInput[][] = [
            [
                {
                    fieldName: "X-API-Key",
                    type: "apiKey:header",
                    value: security?.apiKey,
                },
            ],
        ];
        const securitySettings$ = this.resolveSecurity(...security$);
        const context = {
            operationID: "guestPaymentsUpdate",
            oAuth2Scopes: [],
            securitySource: security$,
        };

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.GuestPaymentsUpdateResponse>()
            .json(200, operations.GuestPaymentsUpdateResponse$inboundSchema, {
                key: "payment-response",
            })
            .json("4XX", errors.GuestPaymentsUpdateResponseBody$inboundSchema, { err: true })
            .fail("5XX")
            .void("default", operations.GuestPaymentsUpdateResponse$inboundSchema)
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Finalize a pending guest payment
     *
     * @remarks
     * Finalize a pending payment being made by a Bolt guest shopper. Upon receipt of a finalized payment result, payment success should be communicated to the shopper.
     */
    async performAction(
        security: operations.GuestPaymentsActionSecurity,
        id: string,
        xPublishableKey: string,
        xMerchantClientId: string,
        paymentActionRequest: components.PaymentActionRequest,
        options?: RequestOptions
    ): Promise<operations.GuestPaymentsActionResponse> {
        const input$: operations.GuestPaymentsActionRequest = {
            id: id,
            xPublishableKey: xPublishableKey,
            xMerchantClientId: xMerchantClientId,
            paymentActionRequest: paymentActionRequest,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.GuestPaymentsActionRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$["payment-action-request"], { explode: true });

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };
        const path$ = this.templateURLComponent("/guest/payments/{id}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            "X-Merchant-Client-Id": encodeSimple$(
                "X-Merchant-Client-Id",
                payload$["X-Merchant-Client-Id"],
                { explode: false, charEncoding: "none" }
            ),
            "X-Publishable-Key": encodeSimple$("X-Publishable-Key", payload$["X-Publishable-Key"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$: SecurityInput[][] = [
            [
                {
                    fieldName: "X-API-Key",
                    type: "apiKey:header",
                    value: security?.apiKey,
                },
            ],
        ];
        const securitySettings$ = this.resolveSecurity(...security$);
        const context = {
            operationID: "guestPaymentsAction",
            oAuth2Scopes: [],
            securitySource: security$,
        };

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.GuestPaymentsActionResponse>()
            .json(200, operations.GuestPaymentsActionResponse$inboundSchema, {
                key: "payment-response",
            })
            .json("4XX", errors.GuestPaymentsActionResponseBody$inboundSchema, { err: true })
            .fail("5XX")
            .void("default", operations.GuestPaymentsActionResponse$inboundSchema)
            .match(response, { extraFields: responseFields$ });

        return result$;
    }
}
