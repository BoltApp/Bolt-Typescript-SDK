/*
 * Code generated by Speakeasy (https://speakeasyapi.dev). DO NOT EDIT.
 */

import { SDKHooks } from "../hooks/hooks.js";
import { SDKOptions, serverURLFromOptions } from "../lib/config.js";
import { encodeJSON as encodeJSON$, encodeSimple as encodeSimple$ } from "../lib/encodings.js";
import { HTTPClient } from "../lib/http.js";
import * as schemas$ from "../lib/schemas.js";
import { ClientSDK, RequestOptions } from "../lib/sdks.js";
import * as components from "../models/components/index.js";
import * as errors from "../models/errors/index.js";
import * as operations from "../models/operations/index.js";

export class LoggedIn extends ClientSDK {
    private readonly options$: SDKOptions & { hooks?: SDKHooks };

    constructor(options: SDKOptions = {}) {
        const opt = options as unknown;
        let hooks: SDKHooks;
        if (
            typeof opt === "object" &&
            opt != null &&
            "hooks" in opt &&
            opt.hooks instanceof SDKHooks
        ) {
            hooks = opt.hooks;
        } else {
            hooks = new SDKHooks();
        }

        super({
            client: options.httpClient || new HTTPClient(),
            baseURL: serverURLFromOptions(options),
            hooks,
        });

        this.options$ = { ...options, hooks };
        void this.options$;
    }

    /**
     * Initialize a Bolt payment for logged in shoppers
     *
     * @remarks
     * Initialize a Bolt logged-in shopper's intent to pay for a cart, using the specified payment method. Payments must be finalized before indicating the payment result to the shopper. Some payment methods will finalize automatically after initialization. For these payments, they will transition directly to "finalized" and the response from Initialize Payment will contain a finalized payment.
     *
     */
    async initialize(
        xPublishableKey: string,
        xMerchantClientId: string,
        paymentInitializeRequest: components.PaymentInitializeRequest,
        options?: RequestOptions
    ): Promise<operations.PaymentsInitializeResponse> {
        const input$: operations.PaymentsInitializeRequest = {
            xPublishableKey: xPublishableKey,
            xMerchantClientId: xMerchantClientId,
            paymentInitializeRequest: paymentInitializeRequest,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.PaymentsInitializeRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$["payment-initialize-request"], {
            explode: true,
        });

        const path$ = this.templateURLComponent("/payments")();

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            "X-Merchant-Client-Id": encodeSimple$(
                "X-Merchant-Client-Id",
                payload$["X-Merchant-Client-Id"],
                { explode: false, charEncoding: "none" }
            ),
            "X-Publishable-Key": encodeSimple$("X-Publishable-Key", payload$["X-Publishable-Key"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "paymentsInitialize",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.PaymentsInitializeResponse>()
            .json(200, operations.PaymentsInitializeResponse$inboundSchema, {
                key: "payment-response",
            })
            .json("4XX", errors.PaymentsInitializeResponseBody$inboundSchema, { err: true })
            .fail("5XX")
            .void("default", operations.PaymentsInitializeResponse$inboundSchema)
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Update a pending payment
     *
     * @remarks
     * Update a payment that is still in the pending state, with new information about the payment.
     */
    async update(
        id: string,
        xPublishableKey: string,
        xMerchantClientId: string,
        paymentUpdateRequest: components.PaymentUpdateRequest,
        options?: RequestOptions
    ): Promise<operations.PaymentsUpdateResponse> {
        const input$: operations.PaymentsUpdateRequest = {
            id: id,
            xPublishableKey: xPublishableKey,
            xMerchantClientId: xMerchantClientId,
            paymentUpdateRequest: paymentUpdateRequest,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.PaymentsUpdateRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$["payment-update-request"], { explode: true });

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };
        const path$ = this.templateURLComponent("/payments/{id}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            "X-Merchant-Client-Id": encodeSimple$(
                "X-Merchant-Client-Id",
                payload$["X-Merchant-Client-Id"],
                { explode: false, charEncoding: "none" }
            ),
            "X-Publishable-Key": encodeSimple$("X-Publishable-Key", payload$["X-Publishable-Key"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "paymentsUpdate",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "PATCH",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.PaymentsUpdateResponse>()
            .json(200, operations.PaymentsUpdateResponse$inboundSchema, { key: "payment-response" })
            .json("4XX", errors.PaymentsUpdateResponseBody$inboundSchema, { err: true })
            .fail("5XX")
            .void("default", operations.PaymentsUpdateResponse$inboundSchema)
            .match(response, { extraFields: responseFields$ });

        return result$;
    }

    /**
     * Finalize a pending payment
     *
     * @remarks
     * Finalize a pending payment being made by a Bolt logged-in shopper. Upon receipt of a finalized payment result, payment success should be communicated to the shopper.
     */
    async performAction(
        id: string,
        xPublishableKey: string,
        xMerchantClientId: string,
        paymentActionRequest: components.PaymentActionRequest,
        options?: RequestOptions
    ): Promise<operations.PaymentsActionResponse> {
        const input$: operations.PaymentsActionRequest = {
            id: id,
            xPublishableKey: xPublishableKey,
            xMerchantClientId: xMerchantClientId,
            paymentActionRequest: paymentActionRequest,
        };

        const payload$ = schemas$.parse(
            input$,
            (value$) => operations.PaymentsActionRequest$outboundSchema.parse(value$),
            "Input validation failed"
        );
        const body$ = encodeJSON$("body", payload$["payment-action-request"], { explode: true });

        const pathParams$ = {
            id: encodeSimple$("id", payload$.id, { explode: false, charEncoding: "percent" }),
        };
        const path$ = this.templateURLComponent("/payments/{id}")(pathParams$);

        const query$ = "";

        const headers$ = new Headers({
            "Content-Type": "application/json",
            Accept: "application/json",
            "X-Merchant-Client-Id": encodeSimple$(
                "X-Merchant-Client-Id",
                payload$["X-Merchant-Client-Id"],
                { explode: false, charEncoding: "none" }
            ),
            "X-Publishable-Key": encodeSimple$("X-Publishable-Key", payload$["X-Publishable-Key"], {
                explode: false,
                charEncoding: "none",
            }),
        });

        const security$ =
            typeof this.options$.security === "function"
                ? await this.options$.security()
                : this.options$.security;

        const context = {
            operationID: "paymentsAction",
            oAuth2Scopes: [],
            securitySource: this.options$.security,
        };
        const securitySettings$ = this.resolveGlobalSecurity(security$);

        const request$ = this.createRequest$(
            context,
            {
                security: securitySettings$,
                method: "POST",
                path: path$,
                headers: headers$,
                query: query$,
                body: body$,
                timeoutMs: options?.timeoutMs || this.options$.timeoutMs || -1,
            },
            options
        );

        const response = await this.do$(request$, {
            context,
            errorCodes: ["4XX", "5XX"],
            retryConfig: options?.retries || this.options$.retryConfig,
            retryCodes: options?.retryCodes || ["429", "500", "502", "503", "504"],
        });

        const responseFields$ = {
            ContentType: response.headers.get("content-type") ?? "application/octet-stream",
            StatusCode: response.status,
            RawResponse: response,
            Headers: {},
        };

        const [result$] = await this.matcher<operations.PaymentsActionResponse>()
            .json(200, operations.PaymentsActionResponse$inboundSchema, { key: "payment-response" })
            .json("4XX", errors.PaymentsActionResponseBody$inboundSchema, { err: true })
            .fail("5XX")
            .void("default", operations.PaymentsActionResponse$inboundSchema)
            .match(response, { extraFields: responseFields$ });

        return result$;
    }
}
